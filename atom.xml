<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>try-catch的博客</title>
  
  
  <link href="/blogs/atom.xml" rel="self"/>
  
  <link href="https://machunlin.github.io/blogs/"/>
  <updated>2019-02-27T06:56:14.898Z</updated>
  <id>https://machunlin.github.io/blogs/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java性能分析与问题定位</title>
    <link href="https://machunlin.github.io/blogs/2019/02/27/java%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    <id>https://machunlin.github.io/blogs/2019/02/27/java性能分析与问题定位/</id>
    <published>2019-02-27T05:14:39.000Z</published>
    <updated>2019-02-27T06:56:14.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>jdk提供的工具类，可以用来获取java进程的内存、线程、垃圾回收等信息。</p><ol><li><p>jstack —— 获取线程堆栈信息：<br><code>jstack -l  7055 &gt; store-back.jstatck</code></p></li><li><p>jmap —— 获取堆中的对象信息（类的实例等）<br><code>jmap -dump:format=b,file=store-back.hprof 12131</code><br>说明：需要使用<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">eclipse MAT</a>或者jhat工具配合，解析dump下来的内存文件。</p></li><li><p>OOM时自动dump方式，在java启动脚本上添加jvm命令：<br><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${目录}</code></p></li><li><p>jstat —— jvm的统计信息，包含内存使用情况、垃圾回收时间、类加载等信息：<br><code>jstat -gcutil 21891 250 7</code><br>  说明：21891 进程号； 250ms 采样间隔时间，单位毫秒； 7 采集次数</p></li></ol><h1 id="APM监控工具"><a href="#APM监控工具" class="headerlink" title="APM监控工具"></a>APM监控工具</h1><p>  通常，排查生产环境的问题，我们不会远程连到服务器，使用jstack、jmap命令获取相关信息，因为这样效率太低，而且生产环境有诸多限制。<br>  我比较习惯使用APM(Application Performance Monitor)工具来快速定位和排查问题，比如<a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">pinpoint</a>就是一款非常优秀的APM工具。</p><p>  在pinpoint首页，我们可以看到应用程序之间的拓扑图，调用次数(一般生产环境采样率为10%)，如下图。<br><img src="http://i1.bvimg.com/678568/54e79a8618a0ed0c.png" alt="pinpoint首页"></p><p>  图片右上角部分（如下图），有很多绿色的小点点，每个点代表一次http请求，横坐标为请求时间，纵坐标为该次请求的耗时（毫秒）；红色的点表示该次请求抛异常。<br><img src="http://i1.bvimg.com/678568/e43f21181a5ea408.png" alt="请求"></p><p>  我们可以用鼠标框住耗时最长的一部分“小点”，就可以查看每个请求的调用链(如下图)，调用链精确到某个应用的某个类的某个方法，并打印出执行的SQL语句；以及每个方法的执行耗时和百分比。<br><img src="http://i1.bvimg.com/678568/cbc9e7368a6233f5.png" alt="调用链"></p><p>  点击“inspector”按钮，可以看到每个应用(jvm进程)的内存分配情况，比如堆、永久区(java8为metaspace)占用空间，GC执行耗时，CPU消耗，每秒事务数(TPS)，活跃线程数，请求响应时间，堆外直接内存空间等等数据。一目了然，犹如上帝视角。<br><img src="http://i1.bvimg.com/678568/ff77eae2abd504e1.png" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;p&gt;jdk提供的工具类，可以用来获取java进程的内存、线程、垃圾回收等信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;jstack —
      
    
    </summary>
    
    
  </entry>
  
</feed>
